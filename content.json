{"pages":[],"posts":[{"title":"Go Module 使用方法","text":"前言相信很多人在接觸到 go module 的時候，肯定對 go.mod, go.sum, go get, go mod tidy, GOPATH 這一大堆的名詞感到十分困惑，我本身在學習 Go 的路程上也在這裡踩到很多坑，深刻感受到在使用前，好好的了解 go module 的名詞以及他們的用途，對於將來很多問題都能迎刃而解！ Go module 是什麼?Go module 是從 Go 1.11 版本開始使用的一個用來管理專案裡面各個 package 版本的一個工具。透過 go.mod 這個檔案，來紀錄管理底下所有 Go 程式碼用到的 package 的版本。 這邊要先做個釐清，很多人包括我，在學習 Go 的時候，一定看到很多教學說要設定 GOPATH，並且把 Go 程式碼都要放到這裡面，才能夠讓 Go 去找到並且執行。但是在使用 Module 的情況下，就先拋開這個 GOPATH 的概念，因為 Module 的出現就是要讓 Go 的程式碼可以在 GOPATH 以外執行！ 建立 Module還是一樣！先拋開之前對於 GOPATH 的概念，當成他是獨立的一個 package 管理模式吧！ 先建立一個資料夾，這個資料夾可以當成是整個專案的資料夾，你的所有 Go 程式碼都能放在這個底下，並且透過 module 統一管理。 12mkdir go-module-tutorialcd go-module-tutorial 接著要在這個資料夾底下，建立 go.mod 這個檔案，透過 go tool 的 go mod init &lt;module name&gt; 來建立，後面的 module name 可以代入自己想要的 module 名稱。 1go mod init mymod 然後就可以 go.mod 被自動建立出來了。你應該可以看到你的資料夾現在呈現下面這個樣子。 12└─ go-module-tutorial └─ go.mod 剛建立完的 go.mod 如下所示，裡面只有一些預設的資料，module 後面代表你的 module 名稱，go 1.13 則表示現在所使用的 Go 版本。目前看起來什麼都沒有，不過在接下來我們去新增 package 之後，就可以看到 go.mod 的變化囉。 123module mymodgo 1.13 在 Module 中使用 Package建立 main為了要讓 Go 可以執行，我們在 go-module-tutorial 底下建立一個 main.go，並且入少許程式碼來當作範例。這邊的 package 為 main 是一個 Go package 特殊例外狀況，只要定義 package 為 main 的程式碼，Go 就會從這邊找程式的進入點。 12345678// go-module-tutorial/main.gopackage mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;This is main!&quot;)} 接著用 go run 執行就可以看到終端機印出 This is main package! 的字樣了。 1go run main.go 1This is main package! 建立 package在 go-module-tutorial 底下，建立一個名叫 greeting 的資料夾，你可以取任意名字都沒關係，建立好的資料夾結構就如下所示。 1234└─ go-module-tutorial └─ greeting └─ main.go └─ go.mod 接著到 greeting 資料夾底下建立 greeting.go，然後將以下的程式碼貼到 greeing.go 中。通常 package 名稱會跟資料夾名稱一樣，方便辨識與管理，同理在 Go 檔案命名時，在這個 package 底下主要的檔案會跟資料夾同樣名稱去命名，同樣也是方便辨識哦。 12345678// go-module-tutorial/greeting/greeting.gopackage greetingimport &quot;fmt&quot;func Greeting() { fmt.Println(&quot;This is Greeting!&quot;)} 這邊把 Greeting 這個 function 字首為大寫，以便在 main.go 裡面可以使用！接著就回到 main.go 來引入 greeting 這個 package。 1234567891011121314// go-module-tutorial/main.gopackage mainimport ( &quot;fmt&quot; &quot;mymod/greeting&quot;)func main() { fmt.Println(&quot;This is main!&quot;) greeting.Greeting()} 重點來了，在 go-module-tutorial 底下的都交由 Module 去控管了，所以可以看到 import 的地方 &quot;mymod/greeting&quot;，這邊使用 Module 名稱當作開頭，底下就以資料夾的結構去定義。接著在 main 裡面使用的時候，package 的名稱直接跟資料夾的名稱一模一樣。執行後就可以看到以下的輸出囉。 12This is main!This is Greeting! 當然也可以在 import 時給定別名，避免重複名稱或是定義更好辨認的名稱哦 1234567891011121314// go-module-tutorial/main.gopackage mainimport ( &quot;fmt&quot; greet &quot;mymod/greeting&quot;)func main() { fmt.Println(&quot;This is main!&quot;) greet.Greeting()} 剛剛也有提到 import 的路徑會是由 Module 名稱後面再加上這個資料夾內的相對路徑來表示，所以可以在 greeting 底下再新增一個 eating package，用 mymod/greeting/eating 就能 import 進來，然後使用 package 名稱 eating 去使用 Eating 這個 function。 12345678// go-module-tutorial/greeting/eating/eating.gopackage eatingimport &quot;fmt&quot;func Eating() { fmt.Println(&quot;This is Eating!&quot;)} 12345678910111213141516// go-module-tutorial/main.gopackage mainimport ( &quot;fmt&quot; &quot;mymod/greeting&quot; &quot;mymod/greeting/eating&quot;)func main() { fmt.Println(&quot;This is main!&quot;) greeting.Greeting() eating.Eating()} 遠端 Module我們在開發的時候，多數時候都會引用第三方的 package 或是 Module，且絕大多數都是使用 Git 的 repository。這邊就講述怎麼用 Module 來管理這些第三方套件各自的版本，來為自己的程式引入第三方套件吧。 這邊使用我自己建立的 Github repository 作為範例，可以使用各自建立的 Package，或是其他 Github, Gitlab 上的第三方套件都可以。這邊使用到的 Github repository 連結在下方供大家使用。 https://github.com/hansenwuwu/go-module-example go getgo get 這個語法可以抓取遠端 package 到本地端，通常會儲存在 $GOPATH/pkg/mod 裡面，這邊 Go 會自動幫忙下載到這個路徑下，並且在使用上也會自己去尋找到這個路徑底下的檔案，不需要多作處理。下載完之後，會同步的更新 go.mod 檔案。 12# go-module-tutorial/go get &quot;github.com/hansenwuwu/go-module-example&quot; 執行後，可以看到終端機印出一些下載的資訊，下載完後，到 go.mod 查看，可以看到這個遠端 Module 被新增到裡面了。go.mod 新增的那行可以看到，後面帶了一長串數字，這是 Go 依照一些規則所命名的版本號碼。在 go get 指令中，可以用 @ 加入版本號碼、commit 號碼、Tag 名稱或是分支名稱，去定義要抓取哪一個版本的。如果像前面範例一樣都不定義的話，會自動抓取 latest 最新的那個版本來使用。 12345module mymodgo 1.13require github.com/hansenwuwu/go-module-example v0.0.0-20211124105957-0f98700dce20 接著到 main.go 裡面用同樣方式去呼叫這個第三方套件，並且使用他的 function。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;mymod/greeting&quot; &quot;mymod/greeting/eating&quot; &quot;github.com/hansenwuwu/go-module-example/say&quot;)func main() { fmt.Println(&quot;This is main!&quot;) greeting.Greeting() eating.Eating() say.SayHello()}/* // terminal outputThis is main!This is Greeting!This is Eating!Say Hello from github.com/hansenwuwu/go-module-example*/ 接著如果我們想要用指令的版本，或是想要把舊的版本替換成指定的版本的時候，都是使用 go get 搭配 @ 版本號碼的做法。以下列出幾個範例： 使用 Tag 指定版本為 v1.0.0 1go get github.com/hansenwuwu/go-module-example@v1.0.0 可以看到 go.mod 檔案隨著版本的更改也同步更改了 12345module mymodgo 1.13require github.com/hansenwuwu/go-module-example v1.0.0 執行同樣的程式後，可以看到輸出被我們改成 v1.0.0 版本的輸出了 1234This is main!This is Greeting!This is Eating!Say Hello from github.com/hansenwuwu/go-module-example v1.0 也可以使用版本的 commit 編號去指定版本 1go get github.com/hansenwuwu/go-module-example@b07a315 1234This is main!This is Greeting!This is Eating!Say Hello from github.com/hansenwuwu/go-module-example v1.0.1 這邊會印出 v1.0.1 的原因是我把這個 commit 給定一個 Tag 為 v1.0.1 總結來說 go get 就是來幫助整個 Module 管裡套件版本的工具，可以新增還不存在的 Module，也可以把原本的版本進行更改。 go mod tidy最後來講一下 go mod tidy 這個指令，這個指令會幫你去抓整個 Module 裡面所有有用到的 package，以及沒有用到的 package 去做整理，將 go.mod 這個檔案裡的套件版本進行更新，並且會自動抓取新的版本。算是一個很方便地功能，但是我本身在開發的時候，還是偏向自己用 go get 指定版本號碼的方式去獲取第三方套件，因為有時候套件之間互相干擾，導致 go mod tidy 自己幫你抓的時候抓了奇怪的版本也說不定。 總結最後總結一下常見的幾個 Go 指令，了解這些 Go 指令的功能與區別之後，往後開發上才能夠正確地運用 Module 囉。 go mod init 建立 Go module go get 取得指定版本的 package，更改已存在 package 的版本 go mod tidy 補上需要的 package 或是去除沒有用到的 package go build, go run, go test 在執行時也會自動在 go.mod 裡面新增套件 參考https://go.dev/blog/using-go-moduleshttps://go.dev/doc/tutorial/create-modulehttps://www.digitalocean.com/community/tutorials/how-to-use-go-modules","link":"/2021/11/24/go-note-2-module/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Module","slug":"Module","link":"/tags/Module/"}],"categories":[{"name":"Go 筆記","slug":"Go-筆記","link":"/categories/Go-%E7%AD%86%E8%A8%98/"}]}